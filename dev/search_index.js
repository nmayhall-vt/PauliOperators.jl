var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Funcitons","title":"Funcitons","text":"CurrentModule = PauliOperators","category":"page"},{"location":"functions/#Functions","page":"Funcitons","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Funcitons","title":"Funcitons","text":"Modules = [PauliOperators]\nOrder   = [:function]","category":"page"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{PauliSum{N}, Number}} where N","page":"Funcitons","title":"Base.:*","text":"Base.:*(ps::PauliSum{N}, a::Number) where {N}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{PauliSum{N}, PauliSum{N}}} where N","page":"Funcitons","title":"Base.:*","text":"Base.-(p1::PauliSum{N}, p2::PauliSum{N}) where {N}\n\nMultiply two PauliSums. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{Pauli{N}, KetBitString{N}}} where N","page":"Funcitons","title":"Base.:*","text":"Base.:*(p::Pauli{N}, KetBitString{N}) where N\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{Pauli{N}, Number}} where N","page":"Funcitons","title":"Base.:*","text":"Base.:*(p::Pauli{N}, c::Number) where {N}\n\nMultiply a Pauli with a number. This returns a PauliSum \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:*","text":"Base.:*(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nMultiply two Pauli's together\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:*-Union{Tuple{N}, Tuple{T}, Tuple{Pauli{N}, Array{T}}} where {T<:Complex, N}","page":"Funcitons","title":"Base.:*","text":"Base.:*(p::Pauli{N}, in::Array{T}) where {T,N}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Union{Tuple{N}, Tuple{PauliSum{N}, PauliSum{N}}} where N","page":"Funcitons","title":"Base.:+","text":"Base.+(p1::PauliSum{N}, p2::PauliSum{N}) where {N}\n\nAdd two PauliSums. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Union{Tuple{N}, Tuple{PauliSum{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:+","text":"Base.:+(ps::PauliSum{N}, p::Pauli{N}) where {N}\n\nAdd a Pauli to a PauliSum. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:+-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:+","text":"Base.:+(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nAdd two Pauli's together. This returns a PauliSum\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:--Union{Tuple{N}, Tuple{PauliSum{N}, PauliSum{N}}} where N","page":"Funcitons","title":"Base.:-","text":"Base.-(p1::PauliSum{N}, p2::PauliSum{N}) where {N}\n\nSubtract two PauliSums. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:--Union{Tuple{ScaledPauli{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Funcitons","title":"Base.:-","text":"Base.:-(p::ScaledPauli{T,N}) where {T,N}\n\nNegate the p. We could either change the coeff or the pauli. Not sure which is best, negate coeff currently\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:<-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:<","text":"Base.:(<)(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nCheck if p1 < p2\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:==-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:==","text":"Base.:(==)(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nCheck if they are equal, return true or false\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:>-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.:>","text":"Base.:(>)(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nCheck if p1 > p2\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.:≈-Union{Tuple{N}, Tuple{PauliSum{N}, PauliSum{N}}} where N","page":"Funcitons","title":"Base.:≈","text":"Base.:≈(p1::PauliSum{N}, p2::PauliSum{N}) where {N}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.Multimedia.display-Tuple{PauliSum}","page":"Funcitons","title":"Base.Multimedia.display","text":"Base.display(ps::PauliSum)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.adjoint-Union{Tuple{PauliSum{N}}, Tuple{N}} where N","page":"Funcitons","title":"Base.adjoint","text":"LinearAlgebra.adjoint(ps::PauliSum{N}) where N\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.hash-Union{Tuple{N}, Tuple{Pauli{N}, UInt64}} where N","page":"Funcitons","title":"Base.hash","text":"Base.hash(p::Pauli{N}, h::UInt) where N\n\nCreate a hash for a Pauli. Because we want to collect matching operators,      with different phases, we don't actually put the phase in the hash\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.show-Union{Tuple{N}, Tuple{IO, KetBitString{N}}} where N","page":"Funcitons","title":"Base.show","text":"Base.show(io::IO, P::Pauli{N}) where N\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.show-Union{Tuple{N}, Tuple{IO, Pauli{N}}} where N","page":"Funcitons","title":"Base.show","text":"Base.show(io::IO, P::PauliMask)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.string-Union{Tuple{KetBitString{N}}, Tuple{N}} where N","page":"Funcitons","title":"Base.string","text":"Base.string(p::KetBitString{N}) where N\n\nDisplay, y = iY\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.string-Union{Tuple{Pauli{N}}, Tuple{N}} where N","page":"Funcitons","title":"Base.string","text":"Base.display(p::Pauli)\n\nDisplay, y = iY\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.sum!-Union{Tuple{N}, Tuple{PauliSum{N}, PauliSum{N}}} where N","page":"Funcitons","title":"Base.sum!","text":"Base.sum!(p1::PauliSum{N}, p2::PauliSum{N}) where {N}\n\nAdd two PauliSums. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.sum!-Union{Tuple{N}, Tuple{PauliSum{N}, Pauli{N}}} where N","page":"Funcitons","title":"Base.sum!","text":"Base.sum!(p1::PauliSum{N}, p2::Pauli{N}) where {N}\n\nAdd a Pauli to a PauliSum. \n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.unique!-Union{Tuple{Array{ScaledPauli{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Funcitons","title":"Base.unique!","text":"Base.unique!(spv::Vector{ScaledPauli{T,N}}) where {T,N}\n\nSort and add duplicates. This modifies spv to be a sorted list of only unique ScaledPauli's\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.unique-Union{Tuple{Array{ScaledPauli{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Funcitons","title":"Base.unique","text":"Base.unique(spv::Vector{ScaledPauli{T,N}}) where {T,N}\n\nSort and add duplicates. This returns a sorted list of only unique ScaledPauli's\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.adjoint!-Union{Tuple{PauliSum{N}}, Tuple{N}} where N","page":"Funcitons","title":"LinearAlgebra.adjoint!","text":"LinearAlgebra.adjoint!(ps::PauliSum{N}) where N\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.mul!-Tuple{PauliSum, Number}","page":"Funcitons","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(ps::PauliSum, a::Number)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.mul!-Union{Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Pauli{N}, Matrix{T}, Any, Any}} where {T, N}","page":"Funcitons","title":"LinearAlgebra.mul!","text":"LinearAlgebra.mul!(C::Matrix{T}, A::Pauli{N}, B::Matrix{T}, α, β) where {T,N}\n\nmul!(C, A, B, α, β) -> C\n\nABα+Cβ. The result is stored in C by overwriting it. Note that C must not be aliased with either A or B.\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.mul!-Union{Tuple{N}, Tuple{T}, Tuple{Matrix{T}, Pauli{N}, Matrix{T}}} where {T, N}","page":"Funcitons","title":"LinearAlgebra.mul!","text":"mult!(out::Matrix{T}, p::Pauli{N}, in::Matrix{T}) where {T,N}\n\nMultiply dense vectors in in with p, storing the result in out. \n\nI think this should be much faster if we were to store vectors as rows,  so that summing over states acts on contiguous data \n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.boson_binary_transformation-Tuple{Any}","page":"Funcitons","title":"PauliOperators.boson_binary_transformation","text":"boson_binary_transformation(nqubits)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.clip!-Tuple{PauliSum}","page":"Funcitons","title":"PauliOperators.clip!","text":"clip!(ps::PauliSum; thresh=1e-16)\n\nDelete Pauli's with coeffs smaller than thresh\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.commute-Union{Tuple{N}, Tuple{Pauli{N}, Pauli{N}}} where N","page":"Funcitons","title":"PauliOperators.commute","text":"commute(p1::Pauli{N}, p2::Pauli{N}) where {N}\n\nCheck if they commute, return true or false\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.commute-Union{Tuple{N}, Tuple{T}, Tuple{ScaledPauli{T, N}, ScaledPauli{T, N}}} where {T, N}","page":"Funcitons","title":"PauliOperators.commute","text":"commute(p1::ScaledPauli{T,N}, p2::ScaledPauli{T,N}) where {T,N}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.expectation_value_sign-Union{Tuple{N}, Tuple{Pauli{N}, KetBitString{N}}} where N","page":"Funcitons","title":"PauliOperators.expectation_value_sign","text":"expectation_value_sign(p::Pauli{N}, ket::Vector{Bool}) where N\n\ncompute expectation value of Pauli o for a product state ket\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.get_phase-Tuple{Pauli}","page":"Funcitons","title":"PauliOperators.get_phase","text":"get_phase(p::Pauli)\n\nReturn the phase of the Pauli, i^θ\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.is_diagonal-Tuple{Pauli}","page":"Funcitons","title":"PauliOperators.is_diagonal","text":"is_diagonal(p::Pauli)\n\nCheck if operator is diagonal in the computational (z) basis. E.g., does this operator consist of only I and/or Z?\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.jordan_wigner-Tuple{Integer, Integer}","page":"Funcitons","title":"PauliOperators.jordan_wigner","text":"jordan_wigner(f::Integer, N::Integer)\n\nTransform a single fermionic creation operator to PauliSum.\n\nArguments\n\nf: orbital index specifying the spin orbital being acted upon by the creation operator, hata_f^dagger\nN: Total number of spin orbitals\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.negate-Union{Tuple{Pauli{N}}, Tuple{N}} where N","page":"Funcitons","title":"PauliOperators.negate","text":"negate(p::Pauli)\n\nMultiply p by -1\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.osum-Union{Tuple{M}, Tuple{N}, Tuple{PauliSum{N}, PauliSum{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.osum","text":"osum(p1::Pauli{N}, p2::Pauli{M}) where {N,M}\n\nReturns the direct sum of two PauliSums\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.osum-Union{Tuple{M}, Tuple{N}, Tuple{PauliSum{N}, Pauli{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.osum","text":"osum(p1::PauliSum{N}, p2::Pauli{M}) where {N,M}\n\nReturns the direct sum of a PauliSum and a Pauli\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.osum-Union{Tuple{M}, Tuple{N}, Tuple{Pauli{N}, PauliSum{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.osum","text":"osum(p1::Pauli{N}, p2::PauliSum{M}) where {N,M}\n\nReturns the direct sum of a PauliSum and a Pauli\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.osum-Union{Tuple{M}, Tuple{N}, Tuple{Pauli{N}, Pauli{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.osum","text":"osum(p1::Pauli{N}, p2::Pauli{M}) where {N,M}\n\nReturns the direct sum of two Paulis\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.otimes-Union{Tuple{M}, Tuple{N}, Tuple{PauliSum{N}, PauliSum{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.otimes","text":"otimes(p1::PauliSum{N}, p2::PauliSum{M}) where {N,M}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.otimes-Union{Tuple{M}, Tuple{N}, Tuple{PauliSum{N}, Pauli{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.otimes","text":"otimes(p1::PauliSum{N}, p2::Pauli{M}) where {N,M}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.otimes-Union{Tuple{M}, Tuple{N}, Tuple{Pauli{N}, PauliSum{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.otimes","text":"otimes(p::Pauli{N}, ps::PauliSum{M}) where {N,M}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.otimes-Union{Tuple{M}, Tuple{N}, Tuple{Pauli{N}, Pauli{M}}} where {N, M}","page":"Funcitons","title":"PauliOperators.otimes","text":"otimes(p1::Pauli{N}, p2::Pauli{M}) where {N,M}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.phasefree-Tuple{Pauli}","page":"Funcitons","title":"PauliOperators.phasefree","text":"phasefree(p::Pauli)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.random_Pauli-Tuple{Any}","page":"Funcitons","title":"PauliOperators.random_Pauli","text":"random_Pauli(N)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"functions/#PauliOperators.rotate_phase-Union{Tuple{N}, Tuple{Pauli{N}, Integer}} where N","page":"Funcitons","title":"PauliOperators.rotate_phase","text":"rotate_phase(p::Pauli{N}, θ::Integer) where N\n\nRotate phase in units of π/2. In otherwords, multiply the phase by i^θ. E.g., mutliplication by -1 is obtained with θ=2.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PauliOperators","category":"page"},{"location":"#PauliOperators","page":"Home","title":"PauliOperators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PauliOperators.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"CurrentModule = PauliOperators","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Modules = [PauliOperators]\nPublic = true \nOrder = [:type]","category":"page"},{"location":"types/#Base.Matrix-Union{Tuple{Array{ScaledPauli{T, N}, 1}}, Tuple{N}, Tuple{T}} where {T, N}","page":"Types","title":"Base.Matrix","text":"Base.Matrix(spv::Vector{ScaledPauli{T,N}}) where {T,N}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.Matrix-Union{Tuple{PauliSum{N}}, Tuple{N}} where N","page":"Types","title":"Base.Matrix","text":"Base.Matrix(ps::PauliSum{N}; T=ComplexF64) where N\n\nCreate a dense Matrix of type T\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.Matrix-Union{Tuple{Pauli{N}}, Tuple{N}} where N","page":"Types","title":"Base.Matrix","text":"Base.Matrix(p::Pauli{N}) where N\n\nCreate dense matrix representation \n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.KetBitString","page":"Types","title":"PauliOperators.KetBitString","text":"An occupation number vector, up to 128 qubits\n\n\n\n\n\n","category":"type"},{"location":"types/#PauliOperators.KetBitString-Tuple{Integer, Integer}","page":"Types","title":"PauliOperators.KetBitString","text":"KetBitString(N::Integer, v::Integer)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.KetBitString-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Types","title":"PauliOperators.KetBitString","text":"KetBitString(vec::Vector{T}) where T<:Union{Bool, Integer}\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.Pauli","page":"Types","title":"PauliOperators.Pauli","text":"In this representation, the Pauli string operator is represented as two binary strings, one for x and one for z.\n\nThe format is as follows: \n\n(i)^\theta Z^z1 X^x1 ⊗ Z^z2 X^x2 ⊗ ⋯ ⊗ Z^zN X^xN\n\nProducts of operators simply concatonate the left and right strings separately. For example, \n\nXYZIY = 11001|01101\n\nTo create a Y operator, bits in the same locations in z and x should be on.  This means that we have a phase to keep track of because Z^1*X^1 = iY.  As such, we end up working with operators of the form:\n\n(i)^\theta σ1 ⊗ σ2 ⊗ σ3 ⊗ ⋯ ⊗ σN,\n\nwhere,\n\nσ ∈ {X, iY, Z, I}\n\n\n\n\n\n","category":"type"},{"location":"types/#PauliOperators.Pauli-Tuple{Integer}","page":"Types","title":"PauliOperators.Pauli","text":"Pauli(N::Integer; X=[], Y=[], Z=[])\n\nconstructor for creating PauliBoolVec by specifying the qubits where each X, Y, and Z gates exist \n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.Pauli-Union{Tuple{I}, Tuple{I, I, Any}} where I<:Integer","page":"Types","title":"PauliOperators.Pauli","text":"Pauli(z::I, x::I) where I<:Integer\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.PauliSum","page":"Types","title":"PauliOperators.PauliSum","text":"ops::Dict{Pauli{N},ComplexF64}\n\nA collection of Paulis, joined by addition. This uses a Dict to store them, however, the specific use cases should probably dictate the container type, so this will probably be removed.\n\n\n\n\n\n","category":"type"},{"location":"types/#PauliOperators.PauliSum-Tuple{Any}","page":"Types","title":"PauliOperators.PauliSum","text":"PauliSum(N)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"types/#PauliOperators.ScaledPauli","page":"Types","title":"PauliOperators.ScaledPauli","text":"coeff::T\npauli::Pauli{N}\n\nSimply a combination of a Pauli with a coefficient. When sorted, only pauli is considered for the comparisons.\n\n\n\n\n\n","category":"type"}]
}
